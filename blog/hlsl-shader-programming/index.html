<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/764c5b44fcd35701.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-b50b1cd6cd07d0ff.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-a05196de8ce4eb35.js" async="" crossorigin=""></script><script src="/_next/static/chunks/472-028e38afb4b2b55c.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-98975b1d82805e63.js" async="" crossorigin=""></script><script src="/_next/static/chunks/187-2b453017649f79a9.js" async=""></script><script src="/_next/static/chunks/app/layout-35d4c2d1421a0087.js" async=""></script><script src="/_next/static/chunks/940-a00d8960f47eca25.js" async=""></script><script src="/_next/static/chunks/619-c6af3a1b7c4972d6.js" async=""></script><script src="/_next/static/chunks/app/blog/%5Bslug%5D/page-9fbe7a295be62d0d.js" async=""></script><title>HLSL着色器编程技巧 - HGL技术博客</title><meta name="description" content="分享HLSL着色器开发中的实用技巧，包括顶点着色器、像素着色器的优化方法，以及常用的视觉效果实现..."/><meta name="author" content="HGL"/><meta name="keywords" content="HLSL, 着色器, 渲染"/><meta property="og:title" content="HLSL着色器编程技巧"/><meta property="og:description" content="分享HLSL着色器开发中的实用技巧，包括顶点着色器、像素着色器的优化方法，以及常用的视觉效果实现..."/><meta property="og:type" content="article"/><meta property="article:published_time" content="2024-01-05"/><meta property="article:author" content="HGL"/><meta property="article:tag" content="HLSL"/><meta property="article:tag" content="着色器"/><meta property="article:tag" content="渲染"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="HLSL着色器编程技巧"/><meta name="twitter:description" content="分享HLSL着色器开发中的实用技巧，包括顶点着色器、像素着色器的优化方法，以及常用的视觉效果实现..."/><link rel="icon" href="/icon.ico?566750784894397f" type="image/x-icon" sizes="64x64"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body class="cursor-none"><div class="fixed pointer-events-none z-[9999] mix-blend-screen"><div class="w-[400px] h-[400px] rounded-full transition-all duration-300 bg-gradient-radial from-blue-500/20 via-blue-500/5 to-transparent" style="background:radial-gradient(circle, rgba(22, 119, 255, 0.2) 0%, rgba(22, 119, 255, 0.05) 40%, transparent 70%);filter:blur(40px)"></div></div><div class="fixed pointer-events-none z-[9998] mix-blend-screen"><div class="w-[200px] h-[200px] rounded-full" style="background:radial-gradient(circle, rgba(114, 46, 209, 0.15) 0%, transparent 60%);filter:blur(30px);transform:scale(1);transition:transform 0.3s ease"></div></div><div class="fixed pointer-events-none z-[10000]"><div class="w-2 h-2 rounded-full transition-all duration-200 bg-blue-400 shadow-[0_0_10px_rgba(22,119,255,0.5)]"></div></div><div class="min-h-screen"></div><script src="/_next/static/chunks/webpack-b50b1cd6cd07d0ff.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/764c5b44fcd35701.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:I[3728,[],\"\"]\n5:I[9928,[],\"\"]\n6:I[3108,[\"187\",\"static/chunks/187-2b453017649f79a9.js\",\"185\",\"static/chunks/app/layout-35d4c2d1421a0087.js\"],\"\"]\n7:I[6954,[],\"\"]\n8:I[7264,[],\"\"]\na:I[2446,[\"187\",\"static/chunks/187-2b453017649f79a9.js\",\"940\",\"static/chunks/940-a00d8960f47eca25.js\",\"619\",\"static/chunks/619-c6af3a1b7c4972d6.js\",\"308\",\"static/chunks/app/blog/%5Bslug%5D/page-9fbe7a295be62d0d.js\"],\"\"]\nb:I[5846,[\"187\",\"static/chunks/187-2b453017649f79a9.js\",\"940\",\"static/chunks/940-a00d8960f47eca25.js\",\"619\",\"stati"])</script><script>self.__next_f.push([1,"c/chunks/619-c6af3a1b7c4972d6.js\",\"308\",\"static/chunks/app/blog/%5Bslug%5D/page-9fbe7a295be62d0d.js\"],\"\"]\nc:I[8995,[\"187\",\"static/chunks/187-2b453017649f79a9.js\",\"940\",\"static/chunks/940-a00d8960f47eca25.js\",\"619\",\"static/chunks/619-c6af3a1b7c4972d6.js\",\"308\",\"static/chunks/app/blog/%5Bslug%5D/page-9fbe7a295be62d0d.js\"],\"\"]\ne:I[6634,[\"187\",\"static/chunks/187-2b453017649f79a9.js\",\"940\",\"static/chunks/940-a00d8960f47eca25.js\",\"619\",\"static/chunks/619-c6af3a1b7c4972d6.js\",\"308\",\"static/chunks/app/blog/%5Bslug%"])</script><script>self.__next_f.push([1,"5D/page-9fbe7a295be62d0d.js\"],\"\"]\nf:I[6995,[\"187\",\"static/chunks/187-2b453017649f79a9.js\",\"940\",\"static/chunks/940-a00d8960f47eca25.js\",\"619\",\"static/chunks/619-c6af3a1b7c4972d6.js\",\"308\",\"static/chunks/app/blog/%5Bslug%5D/page-9fbe7a295be62d0d.js\"],\"\"]\n2c:I[7561,[\"187\",\"static/chunks/187-2b453017649f79a9.js\",\"940\",\"static/chunks/940-a00d8960f47eca25.js\",\"619\",\"static/chunks/619-c6af3a1b7c4972d6.js\",\"308\",\"static/chunks/app/blog/%5Bslug%5D/page-9fbe7a295be62d0d.js\"],\"\"]\n2d:I[5824,[\"187\",\"static/chunks/187-2"])</script><script>self.__next_f.push([1,"b453017649f79a9.js\",\"940\",\"static/chunks/940-a00d8960f47eca25.js\",\"619\",\"static/chunks/619-c6af3a1b7c4972d6.js\",\"308\",\"static/chunks/app/blog/%5Bslug%5D/page-9fbe7a295be62d0d.js\"],\"\"]\n67:I[9937,[\"187\",\"static/chunks/187-2b453017649f79a9.js\",\"940\",\"static/chunks/940-a00d8960f47eca25.js\",\"619\",\"static/chunks/619-c6af3a1b7c4972d6.js\",\"308\",\"static/chunks/app/blog/%5Bslug%5D/page-9fbe7a295be62d0d.js\"],\"\"]\n68:I[9585,[\"187\",\"static/chunks/187-2b453017649f79a9.js\",\"940\",\"static/chunks/940-a00d8960f47eca25.js\",\"619"])</script><script>self.__next_f.push([1,"\",\"static/chunks/619-c6af3a1b7c4972d6.js\",\"308\",\"static/chunks/app/blog/%5Bslug%5D/page-9fbe7a295be62d0d.js\"],\"\"]\nd:T503,"])</script><script>self.__next_f.push([1,"// 像素着色器示例\nstruct PixelInput\n{\n    float4 position : SV_POSITION;\n    float3 worldPos : TEXCOORD0;\n    float3 normal : TEXCOORD1;\n    float2 texCoord : TEXCOORD2;\n    float4 color : COLOR;\n};\n\n// Phong光照模型\nfloat4 CalculatePhongLighting(float3 worldPos, float3 normal, float3 lightDir, float3 viewDir)\n{\n    // 环境光\n    float3 ambient = float3(0.1, 0.1, 0.1);\n    \n    // 漫反射\n    float diff = max(dot(normal, lightDir), 0.0);\n    float3 diffuse = diff * float3(1.0, 1.0, 1.0);\n    \n    // 镜面反射\n    float3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    float3 specular = spec * float3(1.0, 1.0, 1.0);\n    \n    return float4(ambient + diffuse + specular, 1.0);\n}\n\nfloat4 main(PixelInput input) : SV_TARGET\n{\n    // 采样纹理\n    float4 texColor = diffuseTexture.Sample(linearSampler, input.texCoord);\n    \n    // 计算光照\n    float3 lightDir = normalize(-lightDirection);\n    float3 viewDir = normalize(cameraPosition - input.worldPos);\n    float4 lighting = CalculatePhongLighting(input.worldPos, input.normal, lightDir, viewDir);\n    \n    // 最终颜色\n    float4 finalColor = texColor * input.color * lighting;\n    finalColor.a = texColor.a;\n    \n    return finalColor;\n}"])</script><script>self.__next_f.push([1,"11:[\"HLSL\",\"着色器\",\"渲染\"]\n13:{\"type\":\"heading\",\"level\":2,\"id\":\"intro\",\"text\":\"HLSL着色器编程简介\"}\n14:{\"type\":\"paragraph\",\"text\":\"HLSL（High-Level Shading Language）是微软开发的着色器语言，用于DirectX图形编程。它提供了强大的GPU编程能力，可以创建各种视觉效果，从简单的颜色变换到复杂的光照模型。\"}\n15:{\"type\":\"heading\",\"level\":3,\"id\":\"basics\",\"text\":\"HLSL基础语法\"}\n16:{\"type\":\"paragraph\",\"text\":\"HLSL的语法与C语言类似，但有"])</script><script>self.__next_f.push([1,"一些特殊的类型和关键字：\"}\n"])</script><script>self.__next_f.push([1,"17:{\"type\":\"code\",\"language\":\"hlsl\",\"code\":\"// 基本数据类型\\nfloat4 position : POSITION;  // 4D浮点向量\\nfloat3 normal : NORMAL;      // 3D浮点向量\\nfloat2 texCoord : TEXCOORD0; // 2D浮点向量\\nfloat4 color : COLOR;         // 颜色值\\n\\n// 矩阵类型\\nfloat4x4 worldMatrix;\\nfloat3x3 normalMatrix;\\n\\n// 常量缓冲区\\ncbuffer MatrixBuffer : register(b0)\\n{\\n    float4x4 worldViewProj;\\n    float4x4 worldMatrix;\\n    float3 lightDirection;\\n    float padding;\\n};\\n\\n// 纹理和采样器\\nTexture2D diffuseTexture : register(t0);\\nSamplerState linearSampler : register(s0);\"}\n"])</script><script>self.__next_f.push([1,"18:{\"type\":\"heading\",\"level\":3,\"id\":\"vertex\",\"text\":\"顶点着色器\"}\n19:{\"type\":\"paragraph\",\"text\":\"顶点着色器处理每个顶点的数据，包括位置变换、法线计算、纹理坐标传递等：\"}\n"])</script><script>self.__next_f.push([1,"1a:{\"type\":\"code\",\"language\":\"hlsl\",\"code\":\"// 顶点着色器示例\\nstruct VertexInput\\n{\\n    float4 position : POSITION;\\n    float3 normal : NORMAL;\\n    float2 texCoord : TEXCOORD0;\\n    float4 color : COLOR;\\n};\\n\\nstruct VertexOutput\\n{\\n    float4 position : SV_POSITION;\\n    float3 worldPos : TEXCOORD0;\\n    float3 normal : TEXCOORD1;\\n    float2 texCoord : TEXCOORD2;\\n    float4 color : COLOR;\\n};\\n\\nVertexOutput main(VertexInput input)\\n{\\n    VertexOutput output;\\n    \\n    // 变换位置到裁剪空间\\n    output.position = mul(input.position, worldViewProj);\\n    \\n    // 计算世界坐标位置\\n    output.worldPos = mul(input.position, worldMatrix).xyz;\\n    \\n    // 变换法线到世界空间\\n    output.normal = normalize(mul(input.normal, (float3x3)worldMatrix));\\n    \\n    // 传递纹理坐标和颜色\\n    output.texCoord = input.texCoord;\\n    output.color = input.color;\\n    \\n    return output;\\n}\"}\n"])</script><script>self.__next_f.push([1,"1b:{\"type\":\"heading\",\"level\":3,\"id\":\"pixel\",\"text\":\"像素着色器\"}\n1c:{\"type\":\"paragraph\",\"text\":\"像素着色器处理每个像素的颜色计算，包括纹理采样、光照计算、材质混合等：\"}\n1e:T503,"])</script><script>self.__next_f.push([1,"// 像素着色器示例\nstruct PixelInput\n{\n    float4 position : SV_POSITION;\n    float3 worldPos : TEXCOORD0;\n    float3 normal : TEXCOORD1;\n    float2 texCoord : TEXCOORD2;\n    float4 color : COLOR;\n};\n\n// Phong光照模型\nfloat4 CalculatePhongLighting(float3 worldPos, float3 normal, float3 lightDir, float3 viewDir)\n{\n    // 环境光\n    float3 ambient = float3(0.1, 0.1, 0.1);\n    \n    // 漫反射\n    float diff = max(dot(normal, lightDir), 0.0);\n    float3 diffuse = diff * float3(1.0, 1.0, 1.0);\n    \n    // 镜面反射\n    float3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    float3 specular = spec * float3(1.0, 1.0, 1.0);\n    \n    return float4(ambient + diffuse + specular, 1.0);\n}\n\nfloat4 main(PixelInput input) : SV_TARGET\n{\n    // 采样纹理\n    float4 texColor = diffuseTexture.Sample(linearSampler, input.texCoord);\n    \n    // 计算光照\n    float3 lightDir = normalize(-lightDirection);\n    float3 viewDir = normalize(cameraPosition - input.worldPos);\n    float4 lighting = CalculatePhongLighting(input.worldPos, input.normal, lightDir, viewDir);\n    \n    // 最终颜色\n    float4 finalColor = texColor * input.color * lighting;\n    finalColor.a = texColor.a;\n    \n    return finalColor;\n}"])</script><script>self.__next_f.push([1,"1d:{\"type\":\"code\",\"language\":\"hlsl\",\"code\":\"$1e\"}\n1f:{\"type\":\"heading\",\"level\":3,\"id\":\"advanced\",\"text\":\"高级着色器技术\"}\n20:{\"type\":\"paragraph\",\"text\":\"HLSL还支持许多高级着色器技术，可以实现更复杂的视觉效果：\"}\n"])</script><script>self.__next_f.push([1,"21:{\"type\":\"code\",\"language\":\"hlsl\",\"code\":\"// 法线贴图\\nfloat3 CalculateNormalFromMap(float2 texCoord, float3 normal, float3 tangent)\\n{\\n    float3 normalMap = normalTexture.Sample(linearSampler, texCoord).rgb;\\n    normalMap = normalMap * 2.0 - 1.0; // 转换到[-1,1]范围\\n    \\n    float3 bitangent = cross(normal, tangent);\\n    float3x3 tbnMatrix = float3x3(tangent, bitangent, normal);\\n    \\n    return normalize(mul(normalMap, tbnMatrix));\\n}\\n\\n// 视差贴图\\nfloat2 CalculateParallaxOffset(float2 texCoord, float3 viewDir)\\n{\\n    float height = heightTexture.Sample(linearSampler, texCoord).r;\\n    float2 offset = viewDir.xy * height * parallaxScale;\\n    return texCoord - offset;\\n}\\n\\n// 环境光遮蔽\\nfloat CalculateAmbientOcclusion(float3 worldPos, float3 normal)\\n{\\n    float ao = 0.0;\\n    float radius = 0.5;\\n    int samples = 8;\\n    \\n    for (int i = 0; i \u003c samples; i++) {\\n        float3 samplePos = worldPos + randomDirection[i] * radius;\\n        float depth = SampleDepth(samplePos);\\n        ao += step(samplePos.z, depth);\\n    }\\n    \\n    return 1.0 - (ao / samples);\\n}\"}\n"])</script><script>self.__next_f.push([1,"22:{\"type\":\"heading\",\"level\":3,\"id\":\"optimization\",\"text\":\"性能优化\"}\n23:{\"type\":\"paragraph\",\"text\":\"着色器性能优化对游戏渲染性能至关重要：\"}\n25:[\"**减少分支** - 避免在着色器中使用过多的if-else语句\",\"**纹理压缩** - 使用BCn系列压缩格式减少带宽\",\"**LOD系统** - 根据距离使用不同精度的着色器\",\"**提前剔除** - 使用alpha test和depth test\",\"**批处理** - 减少状态切换和draw call\"]\n24:{\"type\":\"list\",\"items\":\"$25\"}\n"])</script><script>self.__next_f.push([1,"26:{\"type\":\"code\",\"language\":\"hlsl\",\"code\":\"// 优化示例：使用lerp替代if\\n// 不好的做法\\nif (factor \u003e 0.5) {\\n    result = color1;\\n} else {\\n    result = color2;\\n}\\n\\n// 好的做法\\nresult = lerp(color2, color1, step(0.5, factor));\\n\\n// 纹理采样优化\\nfloat4 SampleTextureLOD(float2 texCoord, float lod)\\n{\\n    // 根据距离选择不同的纹理\\n    if (lod \u003c 0.5) {\\n        return highResTexture.Sample(linearSampler, texCoord);\\n    } else if (lod \u003c 1.5) {\\n        return medResTexture.Sample(linearSampler, texCoord);\\n    } else {\\n        return lowResTexture.Sample(linearSampler, texCoord);\\n    }\\n}\\n\\n// 计算着色器优化\\n[numthreads(8, 8, 1)]\\nvoid CSMain(uint3 id : SV_DispatchThreadID)\\n{\\n    // 共享内存优化\\n    groupshared float sharedData[64];\\n    \\n    // 线程同步\\n    GroupMemoryBarrierWithGroupSync();\\n    \\n    // 减少全局内存访问\\n    float localValue = sharedData[id.x % 8 + id.y % 8 * 8];\\n}\"}\n"])</script><script>self.__next_f.push([1,"27:{\"type\":\"heading\",\"level\":3,\"id\":\"summary\",\"text\":\"总结\"}\n28:{\"type\":\"paragraph\",\"text\":\"HLSL着色器编程是现代图形编程的核心技能。通过掌握HLSL的语法特性和优化技巧，可以创建出令人印象深刻的视觉效果。在实际开发中，需要根据具体需求选择合适的着色器技术，并在视觉效果和性能之间找到平衡。\"}\n12:[\"$13\",\"$14\",\"$15\",\"$16\",\"$17\",\"$18\",\"$19\",\"$1a\",\"$1b\",\"$1c\",\"$1d\",\"$1f\",\"$20\",\"$21\",\"$22\",\"$23\",\"$24\",\"$26\",\"$27\",\"$28\"]\n2a:{\"t"])</script><script>self.__next_f.push([1,"itle\":\"DirectX 11渲染管线深度解析\",\"slug\":\"directx11-rendering-pipeline\"}\n2b:{\"title\":\"PhysX物理引擎集成实战\",\"slug\":\"physx-integration-guide\"}\n29:{\"prev\":\"$2a\",\"next\":\"$2b\"}\n10:{\"id\":\"hlsl-shader-programming\",\"title\":\"HLSL着色器编程技巧\",\"subtitle\":\"HLSL Shader Programming\",\"category\":\"HLSL\",\"author\":\"HGL\",\"date\":\"2024-01-05\",\"readTime\":\"12分钟\",\"excerpt\":\"分享HLSL着色器开发中的实用技巧，包括顶点着色器、像素着色器的优化方法，以及常用的视觉效"])</script><script>self.__next_f.push([1,"果实现...\",\"tags\":\"$11\",\"featured\":false,\"published\":true,\"content\":\"$12\",\"navigation\":\"$29\"}\n30:[\"DirectX 11\",\"渲染管线\",\"HLSL\"]\n32:{\"type\":\"heading\",\"level\":2,\"id\":\"overview\",\"text\":\"DirectX 11渲染管线概述\"}\n33:{\"type\":\"paragraph\",\"text\":\"DirectX 11的渲染管线是现代图形编程的核心，它定义了从3D几何数据到最终像素输出的完整流程。理解渲染管线的每个阶段对于开发高性能的游戏引擎至关重要。\"}\n34:{\"type\":\"heading\",\"level\":3,\"id\":\"stages\","])</script><script>self.__next_f.push([1,"\"text\":\"渲染管线的主要阶段\"}\n35:{\"type\":\"paragraph\",\"text\":\"DirectX 11渲染管线包含以下主要阶段：\"}\n37:[\"**输入装配器 (Input Assembler)** - 处理顶点数据和索引\",\"**顶点着色器 (Vertex Shader)** - 变换顶点位置和属性\",\"**曲面细分着色器 (Tessellation Shaders)** - 可选的几何细分\",\"**几何着色器 (Geometry Shader)** - 可选的几何处理\",\"**光栅化器 (Rasterizer)** - 将几何图形转换为像素\",\"**像素着色器 (Pixel Shader)** - 计算"])</script><script>self.__next_f.push([1,"最终像素颜色\",\"**输出合并器 (Output Merger)** - 处理深度测试和混合\"]\n36:{\"type\":\"list\",\"items\":\"$37\"}\n38:{\"type\":\"heading\",\"level\":3,\"id\":\"input-assembler\",\"text\":\"输入装配器阶段\"}\n39:{\"type\":\"paragraph\",\"text\":\"输入装配器负责从内存中读取顶点数据，并将其组装成图元（如三角形、线段等）。这个阶段的配置直接影响渲染性能。\"}\n3a:{\"type\":\"code\",\"language\":\"cpp\",\"code\":\"// 设置顶点缓冲区\\nUINT stride = sizeof(Vertex);\\nUINT offset "])</script><script>self.__next_f.push([1,"= 0;\\ndeviceContext-\u003eIASetVertexBuffers(0, 1, \u0026vertexBuffer, \u0026stride, \u0026offset);\\n\\n// 设置索引缓冲区\\ndeviceContext-\u003eIASetIndexBuffer(indexBuffer, DXGI_FORMAT_R32_UINT, 0);\\n\\n// 设置图元拓扑\\ndeviceContext-\u003eIASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\"}\n3b:{\"type\":\"heading\",\"level\":3,\"id\":\"vertex-shader\",\"text\":\"顶点着色器阶段\"}\n3c:{\"type\":\"paragraph\",\"text\":\"顶点着色器是可编程管线阶段，负责变换顶点位置、计算光照和纹理坐标。每个顶点"])</script><script>self.__next_f.push([1,"都会执行一次顶点着色器程序。\"}\n"])</script><script>self.__next_f.push([1,"3d:{\"type\":\"code\",\"language\":\"hlsl\",\"code\":\"// 顶点着色器示例\\ncbuffer MatrixBuffer : register(b0)\\n{\\n    matrix worldMatrix;\\n    matrix viewMatrix;\\n    matrix projectionMatrix;\\n};\\n\\nstruct VertexInput\\n{\\n    float4 position : POSITION;\\n    float3 normal : NORMAL;\\n    float2 texCoord : TEXCOORD0;\\n};\\n\\nstruct VertexOutput\\n{\\n    float4 position : SV_POSITION;\\n    float3 worldPos : POSITION;\\n    float3 normal : NORMAL;\\n    float2 texCoord : TEXCOORD0;\\n};\\n\\nVertexOutput main(VertexInput input)\\n{\\n    VertexOutput output;\\n    \\n    // 变换顶点位置\\n    float4 worldPos = mul(input.position, worldMatrix);\\n    float4 viewPos = mul(worldPos, viewMatrix);\\n    output.position = mul(viewPos, projectionMatrix);\\n    \\n    // 传递世界坐标和法线\\n    output.worldPos = worldPos.xyz;\\n    output.normal = mul(input.normal, (float3x3)worldMatrix);\\n    output.texCoord = input.texCoord;\\n    \\n    return output;\\n}\"}\n"])</script><script>self.__next_f.push([1,"3e:{\"type\":\"heading\",\"level\":3,\"id\":\"pixel-shader\",\"text\":\"像素着色器阶段\"}\n3f:{\"type\":\"paragraph\",\"text\":\"像素着色器计算每个像素的最终颜色。这是实现各种视觉效果的关键阶段，包括光照、纹理采样、材质计算等。\"}\n"])</script><script>self.__next_f.push([1,"40:{\"type\":\"code\",\"language\":\"hlsl\",\"code\":\"// 像素着色器示例\\nTexture2D diffuseTexture : register(t0);\\nSamplerState textureSampler : register(s0);\\n\\ncbuffer LightBuffer : register(b0)\\n{\\n    float3 lightDirection;\\n    float lightIntensity;\\n    float4 lightColor;\\n};\\n\\nstruct PixelInput\\n{\\n    float4 position : SV_POSITION;\\n    float3 worldPos : POSITION;\\n    float3 normal : NORMAL;\\n    float2 texCoord : TEXCOORD0;\\n};\\n\\nfloat4 main(PixelInput input) : SV_TARGET\\n{\\n    // 采样漫反射纹理\\n    float4 textureColor = diffuseTexture.Sample(textureSampler, input.texCoord);\\n    \\n    // 计算光照\\n    float3 normalizedNormal = normalize(input.normal);\\n    float lightFactor = max(dot(normalizedNormal, -lightDirection), 0.0f);\\n    \\n    // 计算最终颜色\\n    float4 finalColor = textureColor * lightColor * lightFactor * lightIntensity;\\n    finalColor.a = textureColor.a;\\n    \\n    return finalColor;\\n}\"}\n"])</script><script>self.__next_f.push([1,"41:{\"type\":\"heading\",\"level\":3,\"id\":\"optimization\",\"text\":\"性能优化技巧\"}\n42:{\"type\":\"paragraph\",\"text\":\"优化DirectX 11渲染性能的关键技巧：\"}\n44:[\"**批处理** - 减少Draw Call数量\",\"**实例化渲染** - 高效渲染大量相似对象\",\"**纹理图集** - 减少纹理切换开销\",\"**LOD系统** - 根据距离调整细节级别\",\"**视锥剔除** - 避免渲染不可见对象\"]\n43:{\"type\":\"list\",\"items\":\"$44\"}\n45:{\"type\":\"heading\",\"level\":3,\"id\":\"summary\",\"text\":\"总结\"}\n46:{\"type\":\""])</script><script>self.__next_f.push([1,"paragraph\",\"text\":\"DirectX 11渲染管线为现代游戏开发提供了强大而灵活的图形渲染能力。深入理解每个阶段的工作原理和优化方法，是开发高性能游戏引擎的基础。通过合理的设计和优化，可以充分发挥现代GPU的计算能力。\"}\n31:[\"$32\",\"$33\",\"$34\",\"$35\",\"$36\",\"$38\",\"$39\",\"$3a\",\"$3b\",\"$3c\",\"$3d\",\"$3e\",\"$3f\",\"$40\",\"$41\",\"$42\",\"$43\",\"$45\",\"$46\"]\n48:{\"title\":\"PhysX物理引擎集成实战\",\"slug\":\"physx-integration-guide\"}\n49:{\"title\":\"HLSL着色"])</script><script>self.__next_f.push([1,"器编程技巧\",\"slug\":\"hlsl-shader-programming\"}\n47:{\"prev\":\"$48\",\"next\":\"$49\"}\n2f:{\"id\":\"directx11-rendering-pipeline\",\"title\":\"DirectX 11渲染管线深度解析\",\"subtitle\":\"DirectX 11 Rendering Pipeline\",\"category\":\"DirectX\",\"author\":\"HGL\",\"date\":\"2024-01-15\",\"readTime\":\"10分钟\",\"excerpt\":\"深入探讨DirectX 11的渲染管线架构，包括输入装配器、顶点着色器、像素着色器等各个阶段的详细实现，以及如何优化渲染性能...\",\"tags\":\"$30\",\"featured\":false,\"published\":tr"])</script><script>self.__next_f.push([1,"ue,\"content\":\"$31\",\"navigation\":\"$47\"}\n4b:[\"PhysX\",\"物理引擎\",\"碰撞检测\"]\n4d:{\"type\":\"heading\",\"level\":2,\"id\":\"intro\",\"text\":\"PhysX物理引擎简介\"}\n4e:{\"type\":\"paragraph\",\"text\":\"PhysX是NVIDIA开发的实时物理引擎，广泛应用于游戏开发中。它提供了刚体动力学、软体模拟、流体模拟、布料模拟等丰富的物理效果。本文将详细介绍如何在自研游戏引擎中集成PhysX。\"}\n4f:{\"type\":\"heading\",\"level\":3,\"id\":\"setup\",\"text\":\"环境配置\"}\n50:{\"type\""])</script><script>self.__next_f.push([1,":\"paragraph\",\"text\":\"首先需要下载并配置PhysX SDK：\"}\n52:[\"从NVIDIA官网下载PhysX SDK\",\"解压到项目目录\",\"配置Visual Studio项目设置\"]\n51:{\"type\":\"list\",\"ordered\":true,\"items\":\"$52\"}\n53:{\"type\":\"code\",\"language\":\"cpp\",\"code\":\"// 项目配置示例\\n// 包含目录\\n$(PhysXSDK)/Include\\n$(PhysXSDK)/Include/common\\n$(PhysXSDK)/Include/geometry\\n$(PhysXSDK)/Include/foundation\\n\\n// 库目录\\n$(PhysXSDK)/Lib/$(Platform)/$(Configuration)\\n\\n// 链接库\\nPhysX_64.lib\\nPhysXCommon_64.lib\\"])</script><script>self.__next_f.push([1,"nPhysXFoundation_64.lib\\nPhysXCooking_64.lib\"}\n54:{\"type\":\"heading\",\"level\":3,\"id\":\"init\",\"text\":\"初始化PhysX\"}\n55:{\"type\":\"paragraph\",\"text\":\"PhysX的初始化包括创建基金会、物理系统、场景等核心组件：\"}\n"])</script><script>self.__next_f.push([1,"56:{\"type\":\"code\",\"language\":\"cpp\",\"code\":\"// PhysX初始化代码\\n#include \u003cPxPhysicsAPI.h\u003e\\n\\nusing namespace physx;\\n\\nclass PhysicsManager {\\nprivate:\\n    PxFoundation* foundation;\\n    PxPhysics* physics;\\n    PxScene* scene;\\n    PxDefaultAllocator allocator;\\n    PxDefaultErrorCallback errorCallback;\\n    \\npublic:\\n    bool Initialize() {\\n        // 创建基金会\\n        foundation = PxCreateFoundation(PX_PHYSICS_VERSION, allocator, errorCallback);\\n        if (!foundation) return false;\\n        \\n        // 创建物理系统\\n        physics = PxCreatePhysics(PX_PHYSICS_VERSION, *foundation, PxTolerancesScale());\\n        if (!physics) return false;\\n        \\n        // 创建场景描述\\n        PxSceneDesc sceneDesc(physics-\u003egetTolerancesScale());\\n        sceneDesc.gravity = PxVec3(0.0f, -9.81f, 0.0f);\\n        sceneDesc.cpuDispatcher = PxDefaultCpuDispatcherCreate(2);\\n        sceneDesc.filterShader = PxDefaultSimulationFilterShader;\\n        \\n        // 创建场景\\n        scene = physics-\u003ecreateScene(sceneDesc);\\n        if (!scene) return false;\\n        \\n        return true;\\n    }\\n};\"}\n"])</script><script>self.__next_f.push([1,"57:{\"type\":\"heading\",\"level\":3,\"id\":\"rigidbody\",\"text\":\"刚体物理\"}\n58:{\"type\":\"paragraph\",\"text\":\"刚体是物理引擎中最基本的概念，它具有质量、速度、加速度等物理属性：\"}\n"])</script><script>self.__next_f.push([1,"59:{\"type\":\"code\",\"language\":\"cpp\",\"code\":\"// 创建刚体\\nPxRigidDynamic* CreateDynamicBox(const PxVec3\u0026 position, const PxVec3\u0026 halfSize, float density) {\\n    // 创建形状\\n    PxShape* shape = physics-\u003ecreateShape(PxBoxGeometry(halfSize), *material);\\n    \\n    // 创建刚体\\n    PxTransform transform(position);\\n    PxRigidDynamic* body = physics-\u003ecreateRigidDynamic(transform);\\n    body-\u003eattachShape(*shape);\\n    \\n    // 计算质量和惯性\\n    PxRigidBodyExt::updateMassAndInertia(*body, density);\\n    \\n    // 添加到场景\\n    scene-\u003eaddActor(*body);\\n    \\n    return body;\\n}\\n\\n// 创建静态物体\\nPxRigidStatic* CreateStaticBox(const PxVec3\u0026 position, const PxVec3\u0026 halfSize) {\\n    // 创建形状\\n    PxShape* shape = physics-\u003ecreateShape(PxBoxGeometry(halfSize), *material);\\n    \\n    // 创建静态物体\\n    PxTransform transform(position);\\n    PxRigidStatic* body = physics-\u003ecreateRigidStatic(transform);\\n    body-\u003eattachShape(*shape);\\n    \\n    // 添加到场景\\n    scene-\u003eaddActor(*body);\\n    \\n    return body;\\n}\"}\n"])</script><script>self.__next_f.push([1,"5a:{\"type\":\"heading\",\"level\":3,\"id\":\"collision\",\"text\":\"碰撞检测\"}\n5b:{\"type\":\"paragraph\",\"text\":\"PhysX提供了强大的碰撞检测系统，包括碰撞形状、过滤器和碰撞回调：\"}\n"])</script><script>self.__next_f.push([1,"5c:{\"type\":\"code\",\"language\":\"cpp\",\"code\":\"// 碰撞回调类\\nclass CollisionCallback : public PxSimulationEventCallback {\\npublic:\\n    void onContact(const PxContactPairHeader\u0026 pairHeader, \\n                   const PxContactPair* pairs, PxU32 nbPairs) override {\\n        for (PxU32 i = 0; i \u003c nbPairs; i++) {\\n            const PxContactPair\u0026 cp = pairs[i];\\n            \\n            // 检查碰撞开始\\n            if (cp.events \u0026 PxPairFlag::eNOTIFY_TOUCH_FOUND) {\\n                std::cout \u003c\u003c \\\"Collision detected!\\\" \u003c\u003c std::endl;\\n            }\\n            \\n            // 检查碰撞结束\\n            if (cp.events \u0026 PxPairFlag::eNOTIFY_TOUCH_LOST) {\\n                std::cout \u003c\u003c \\\"Collision ended!\\\" \u003c\u003c std::endl;\\n            }\\n        }\\n    }\\n    \\n    // 其他回调函数...\\n};\\n\\n// 设置碰撞过滤\\nvoid SetupCollisionFiltering() {\\n    PxFilterData filterData;\\n    filterData.word0 = 0x1; // 类别1\\n    filterData.word1 = 0x2; // 与类别2碰撞\\n    \\n    PxShape* shape = ...;\\n    shape-\u003esetSimulationFilterData(filterData);\\n}\"}\n"])</script><script>self.__next_f.push([1,"5d:{\"type\":\"heading\",\"level\":3,\"id\":\"optimization\",\"text\":\"性能优化\"}\n5e:{\"type\":\"paragraph\",\"text\":\"PhysX物理引擎的性能优化是游戏开发中的重要环节：\"}\n60:[\"**批处理** - 减少物理模拟的调用次数\",\"**LOD系统** - 根据距离调整物理精度\",\"**睡眠机制** - 静止物体进入睡眠状态\",\"**区域划分** - 使用空间分区优化碰撞检测\",\"**多线程** - 利用多核CPU进行并行计算\"]\n5f:{\"type\":\"list\",\"items\":\"$60\"}\n"])</script><script>self.__next_f.push([1,"61:{\"type\":\"code\",\"language\":\"cpp\",\"code\":\"// 性能优化设置\\nvoid OptimizePhysicsScene() {\\n    // 设置时间步长\\n    scene-\u003esetGravity(PxVec3(0.0f, -9.81f, 0.0f));\\n    \\n    // 启用睡眠机制\\n    scene-\u003esetFlag(PxSceneFlag::eENABLE_CCD, true);\\n    scene-\u003esetFlag(PxSceneFlag::eENABLE_ACTIVE_ACTORS, true);\\n    \\n    // 设置求解器迭代次数\\n    scene-\u003esetSolverBatchSize(PxU32(50));\\n    scene-\u003esetSolverIterationCount(4);\\n    \\n    // 启用连续碰撞检测\\n    PxSetWarnOnDeprecatedAPI(true);\\n}\\n\\n// 批处理物理更新\\nvoid UpdatePhysics(float deltaTime) {\\n    // 固定时间步长\\n    const float fixedTimeStep = 1.0f / 60.0f;\\n    accumulator += deltaTime;\\n    \\n    while (accumulator \u003e= fixedTimeStep) {\\n        scene-\u003esimulate(fixedTimeStep);\\n        scene-\u003efetchResults(true);\\n        accumulator -= fixedTimeStep;\\n    }\\n}\"}\n"])</script><script>self.__next_f.push([1,"62:{\"type\":\"heading\",\"level\":3,\"id\":\"summary\",\"text\":\"总结\"}\n63:{\"type\":\"paragraph\",\"text\":\"PhysX物理引擎为游戏开发提供了强大而完整的物理模拟解决方案。通过合理的架构设计和性能优化，可以在游戏中实现逼真的物理效果。掌握PhysX的集成技术，是开发高质量3D游戏的重要技能。\"}\n4c:[\"$4d\",\"$4e\",\"$4f\",\"$50\",\"$51\",\"$53\",\"$54\",\"$55\",\"$56\",\"$57\",\"$58\",\"$59\",\"$5a\",\"$5b\",\"$5c\",\"$5d\",\"$5e\",\"$5f\",\"$61\",\"$62\",\"$63\"]\n65:{\"title\":\"HLSL着色器编程"])</script><script>self.__next_f.push([1,"技巧\",\"slug\":\"hlsl-shader-programming\"}\n66:{\"title\":\"DirectX 11渲染管线深度解析\",\"slug\":\"directx11-rendering-pipeline\"}\n64:{\"prev\":\"$65\",\"next\":\"$66\"}\n4a:{\"id\":\"physx-integration-guide\",\"title\":\"PhysX物理引擎集成实战\",\"subtitle\":\"PhysX Integration Guide\",\"category\":\"PhysX\",\"author\":\"HGL\",\"date\":\"2024-01-10\",\"readTime\":\"12分钟\",\"excerpt\":\"从零开始集成PhysX物理引擎到游戏项目中，包括刚体物理、碰撞检测、约束系统等核心功能的实现和优化技巧...\",\"tag"])</script><script>self.__next_f.push([1,"s\":\"$4b\",\"featured\":false,\"published\":true,\"content\":\"$4c\",\"navigation\":\"$64\"}\n2e:[\"$2f\",\"$10\",\"$4a\"]\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/764c5b44fcd35701.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"8N3pHZZrDRdvwbm2TIZ4i\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/hlsl-shader-programming/\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"hlsl-shader-programming\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"hlsl-shader-programming\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L4\"],\"globalErrorComponent\":\"$5\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"cursor-none\",\"children\":[[\"$\",\"$L6\",null,{}],[\"$\",\"div\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",[\"slug\",\"hlsl-shader-programming\",\"d\"],\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$L9\",[\"$\",\"$La\",null,{\"children\":[[\"$\",\"$Lb\",null,{}],[\"$\",\"main\",null,{\"className\":\"min-h-screen bg-gradient-to-br from-slate-50 to-white\",\"children\":[[\"$\",\"div\",null,{\"className\":\"min-h-[60vh] flex items-center w-full bg-gradient-to-br from-white to-gray-50\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-7xl mx-auto w-full px-4 sm:px-6 lg:px-8\",\"children\":[\"$\",\"$Lc\",null,{\"post\":{\"id\":\"hlsl-shader-programming\",\"title\":\"HLSL着色器编程技巧\",\"subtitle\":\"HLSL Shader Programming\",\"category\":\"HLSL\",\"author\":\"HGL\",\"date\":\"2024-01-05\",\"readTime\":\"12分钟\",\"excerpt\":\"分享HLSL着色器开发中的实用技巧，包括顶点着色器、像素着色器的优化方法，以及常用的视觉效果实现...\",\"tags\":[\"HLSL\",\"着色器\",\"渲染\"],\"featured\":false,\"published\":true,\"content\":[{\"type\":\"heading\",\"level\":2,\"id\":\"intro\",\"text\":\"HLSL着色器编程简介\"},{\"type\":\"paragraph\",\"text\":\"HLSL（High-Level Shading Language）是微软开发的着色器语言，用于DirectX图形编程。它提供了强大的GPU编程能力，可以创建各种视觉效果，从简单的颜色变换到复杂的光照模型。\"},{\"type\":\"heading\",\"level\":3,\"id\":\"basics\",\"text\":\"HLSL基础语法\"},{\"type\":\"paragraph\",\"text\":\"HLSL的语法与C语言类似，但有一些特殊的类型和关键字：\"},{\"type\":\"code\",\"language\":\"hlsl\",\"code\":\"// 基本数据类型\\nfloat4 position : POSITION;  // 4D浮点向量\\nfloat3 normal : NORMAL;      // 3D浮点向量\\nfloat2 texCoord : TEXCOORD0; // 2D浮点向量\\nfloat4 color : COLOR;         // 颜色值\\n\\n// 矩阵类型\\nfloat4x4 worldMatrix;\\nfloat3x3 normalMatrix;\\n\\n// 常量缓冲区\\ncbuffer MatrixBuffer : register(b0)\\n{\\n    float4x4 worldViewProj;\\n    float4x4 worldMatrix;\\n    float3 lightDirection;\\n    float padding;\\n};\\n\\n// 纹理和采样器\\nTexture2D diffuseTexture : register(t0);\\nSamplerState linearSampler : register(s0);\"},{\"type\":\"heading\",\"level\":3,\"id\":\"vertex\",\"text\":\"顶点着色器\"},{\"type\":\"paragraph\",\"text\":\"顶点着色器处理每个顶点的数据，包括位置变换、法线计算、纹理坐标传递等：\"},{\"type\":\"code\",\"language\":\"hlsl\",\"code\":\"// 顶点着色器示例\\nstruct VertexInput\\n{\\n    float4 position : POSITION;\\n    float3 normal : NORMAL;\\n    float2 texCoord : TEXCOORD0;\\n    float4 color : COLOR;\\n};\\n\\nstruct VertexOutput\\n{\\n    float4 position : SV_POSITION;\\n    float3 worldPos : TEXCOORD0;\\n    float3 normal : TEXCOORD1;\\n    float2 texCoord : TEXCOORD2;\\n    float4 color : COLOR;\\n};\\n\\nVertexOutput main(VertexInput input)\\n{\\n    VertexOutput output;\\n    \\n    // 变换位置到裁剪空间\\n    output.position = mul(input.position, worldViewProj);\\n    \\n    // 计算世界坐标位置\\n    output.worldPos = mul(input.position, worldMatrix).xyz;\\n    \\n    // 变换法线到世界空间\\n    output.normal = normalize(mul(input.normal, (float3x3)worldMatrix));\\n    \\n    // 传递纹理坐标和颜色\\n    output.texCoord = input.texCoord;\\n    output.color = input.color;\\n    \\n    return output;\\n}\"},{\"type\":\"heading\",\"level\":3,\"id\":\"pixel\",\"text\":\"像素着色器\"},{\"type\":\"paragraph\",\"text\":\"像素着色器处理每个像素的颜色计算，包括纹理采样、光照计算、材质混合等：\"},{\"type\":\"code\",\"language\":\"hlsl\",\"code\":\"$d\"},{\"type\":\"heading\",\"level\":3,\"id\":\"advanced\",\"text\":\"高级着色器技术\"},{\"type\":\"paragraph\",\"text\":\"HLSL还支持许多高级着色器技术，可以实现更复杂的视觉效果：\"},{\"type\":\"code\",\"language\":\"hlsl\",\"code\":\"// 法线贴图\\nfloat3 CalculateNormalFromMap(float2 texCoord, float3 normal, float3 tangent)\\n{\\n    float3 normalMap = normalTexture.Sample(linearSampler, texCoord).rgb;\\n    normalMap = normalMap * 2.0 - 1.0; // 转换到[-1,1]范围\\n    \\n    float3 bitangent = cross(normal, tangent);\\n    float3x3 tbnMatrix = float3x3(tangent, bitangent, normal);\\n    \\n    return normalize(mul(normalMap, tbnMatrix));\\n}\\n\\n// 视差贴图\\nfloat2 CalculateParallaxOffset(float2 texCoord, float3 viewDir)\\n{\\n    float height = heightTexture.Sample(linearSampler, texCoord).r;\\n    float2 offset = viewDir.xy * height * parallaxScale;\\n    return texCoord - offset;\\n}\\n\\n// 环境光遮蔽\\nfloat CalculateAmbientOcclusion(float3 worldPos, float3 normal)\\n{\\n    float ao = 0.0;\\n    float radius = 0.5;\\n    int samples = 8;\\n    \\n    for (int i = 0; i \u003c samples; i++) {\\n        float3 samplePos = worldPos + randomDirection[i] * radius;\\n        float depth = SampleDepth(samplePos);\\n        ao += step(samplePos.z, depth);\\n    }\\n    \\n    return 1.0 - (ao / samples);\\n}\"},{\"type\":\"heading\",\"level\":3,\"id\":\"optimization\",\"text\":\"性能优化\"},{\"type\":\"paragraph\",\"text\":\"着色器性能优化对游戏渲染性能至关重要：\"},{\"type\":\"list\",\"items\":[\"**减少分支** - 避免在着色器中使用过多的if-else语句\",\"**纹理压缩** - 使用BCn系列压缩格式减少带宽\",\"**LOD系统** - 根据距离使用不同精度的着色器\",\"**提前剔除** - 使用alpha test和depth test\",\"**批处理** - 减少状态切换和draw call\"]},{\"type\":\"code\",\"language\":\"hlsl\",\"code\":\"// 优化示例：使用lerp替代if\\n// 不好的做法\\nif (factor \u003e 0.5) {\\n    result = color1;\\n} else {\\n    result = color2;\\n}\\n\\n// 好的做法\\nresult = lerp(color2, color1, step(0.5, factor));\\n\\n// 纹理采样优化\\nfloat4 SampleTextureLOD(float2 texCoord, float lod)\\n{\\n    // 根据距离选择不同的纹理\\n    if (lod \u003c 0.5) {\\n        return highResTexture.Sample(linearSampler, texCoord);\\n    } else if (lod \u003c 1.5) {\\n        return medResTexture.Sample(linearSampler, texCoord);\\n    } else {\\n        return lowResTexture.Sample(linearSampler, texCoord);\\n    }\\n}\\n\\n// 计算着色器优化\\n[numthreads(8, 8, 1)]\\nvoid CSMain(uint3 id : SV_DispatchThreadID)\\n{\\n    // 共享内存优化\\n    groupshared float sharedData[64];\\n    \\n    // 线程同步\\n    GroupMemoryBarrierWithGroupSync();\\n    \\n    // 减少全局内存访问\\n    float localValue = sharedData[id.x % 8 + id.y % 8 * 8];\\n}\"},{\"type\":\"heading\",\"level\":3,\"id\":\"summary\",\"text\":\"总结\"},{\"type\":\"paragraph\",\"text\":\"HLSL着色器编程是现代图形编程的核心技能。通过掌握HLSL的语法特性和优化技巧，可以创建出令人印象深刻的视觉效果。在实际开发中，需要根据具体需求选择合适的着色器技术，并在视觉效果和性能之间找到平衡。\"}],\"navigation\":{\"prev\":{\"title\":\"DirectX 11渲染管线深度解析\",\"slug\":\"directx11-rendering-pipeline\"},\"next\":{\"title\":\"PhysX物理引擎集成实战\",\"slug\":\"physx-integration-guide\"}}}}]}]}],[\"$\",\"$Le\",null,{\"variant\":\"professional\",\"padding\":\"lg\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-7xl mx-auto\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col lg:flex-row gap-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex-1 lg:max-w-4xl\",\"children\":[\"$\",\"$Lf\",null,{\"post\":\"$10\"}]}],[\"$\",\"div\",null,{\"className\":\"lg:hidden w-full\",\"children\":[\"$\",\"div\",null,{\"className\":\"space-y-6\",\"children\":[[\"$\",\"$L2c\",null,{\"post\":\"$10\"}],[\"$\",\"$L2d\",null,{\"post\":\"$10\",\"allPosts\":[{\"id\":\"directx11-rendering-pipeline\",\"title\":\"DirectX 11渲染管线深度解析\",\"subtitle\":\"DirectX 11 Rendering Pipeline\",\"category\":\"DirectX\",\"author\":\"HGL\",\"date\":\"2024-01-15\",\"readTime\":\"10分钟\",\"excerpt\":\"深入探讨DirectX 11的渲染管线架构，包括输入装配器、顶点着色器、像素着色器等各个阶段的详细实现，以及如何优化渲染性能...\",\"tags\":[\"DirectX 11\",\"渲染管线\",\"HLSL\"],\"featured\":false,\"published\":true,\"content\":[{\"type\":\"heading\",\"level\":2,\"id\":\"overview\",\"text\":\"DirectX 11渲染管线概述\"},{\"type\":\"paragraph\",\"text\":\"DirectX 11的渲染管线是现代图形编程的核心，它定义了从3D几何数据到最终像素输出的完整流程。理解渲染管线的每个阶段对于开发高性能的游戏引擎至关重要。\"},{\"type\":\"heading\",\"level\":3,\"id\":\"stages\",\"text\":\"渲染管线的主要阶段\"},{\"type\":\"paragraph\",\"text\":\"DirectX 11渲染管线包含以下主要阶段：\"},{\"type\":\"list\",\"items\":[\"**输入装配器 (Input Assembler)** - 处理顶点数据和索引\",\"**顶点着色器 (Vertex Shader)** - 变换顶点位置和属性\",\"**曲面细分着色器 (Tessellation Shaders)** - 可选的几何细分\",\"**几何着色器 (Geometry Shader)** - 可选的几何处理\",\"**光栅化器 (Rasterizer)** - 将几何图形转换为像素\",\"**像素着色器 (Pixel Shader)** - 计算最终像素颜色\",\"**输出合并器 (Output Merger)** - 处理深度测试和混合\"]},{\"type\":\"heading\",\"level\":3,\"id\":\"input-assembler\",\"text\":\"输入装配器阶段\"},{\"type\":\"paragraph\",\"text\":\"输入装配器负责从内存中读取顶点数据，并将其组装成图元（如三角形、线段等）。这个阶段的配置直接影响渲染性能。\"},{\"type\":\"code\",\"language\":\"cpp\",\"code\":\"// 设置顶点缓冲区\\nUINT stride = sizeof(Vertex);\\nUINT offset = 0;\\ndeviceContext-\u003eIASetVertexBuffers(0, 1, \u0026vertexBuffer, \u0026stride, \u0026offset);\\n\\n// 设置索引缓冲区\\ndeviceContext-\u003eIASetIndexBuffer(indexBuffer, DXGI_FORMAT_R32_UINT, 0);\\n\\n// 设置图元拓扑\\ndeviceContext-\u003eIASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\"},{\"type\":\"heading\",\"level\":3,\"id\":\"vertex-shader\",\"text\":\"顶点着色器阶段\"},{\"type\":\"paragraph\",\"text\":\"顶点着色器是可编程管线阶段，负责变换顶点位置、计算光照和纹理坐标。每个顶点都会执行一次顶点着色器程序。\"},{\"type\":\"code\",\"language\":\"hlsl\",\"code\":\"// 顶点着色器示例\\ncbuffer MatrixBuffer : register(b0)\\n{\\n    matrix worldMatrix;\\n    matrix viewMatrix;\\n    matrix projectionMatrix;\\n};\\n\\nstruct VertexInput\\n{\\n    float4 position : POSITION;\\n    float3 normal : NORMAL;\\n    float2 texCoord : TEXCOORD0;\\n};\\n\\nstruct VertexOutput\\n{\\n    float4 position : SV_POSITION;\\n    float3 worldPos : POSITION;\\n    float3 normal : NORMAL;\\n    float2 texCoord : TEXCOORD0;\\n};\\n\\nVertexOutput main(VertexInput input)\\n{\\n    VertexOutput output;\\n    \\n    // 变换顶点位置\\n    float4 worldPos = mul(input.position, worldMatrix);\\n    float4 viewPos = mul(worldPos, viewMatrix);\\n    output.position = mul(viewPos, projectionMatrix);\\n    \\n    // 传递世界坐标和法线\\n    output.worldPos = worldPos.xyz;\\n    output.normal = mul(input.normal, (float3x3)worldMatrix);\\n    output.texCoord = input.texCoord;\\n    \\n    return output;\\n}\"},{\"type\":\"heading\",\"level\":3,\"id\":\"pixel-shader\",\"text\":\"像素着色器阶段\"},{\"type\":\"paragraph\",\"text\":\"像素着色器计算每个像素的最终颜色。这是实现各种视觉效果的关键阶段，包括光照、纹理采样、材质计算等。\"},{\"type\":\"code\",\"language\":\"hlsl\",\"code\":\"// 像素着色器示例\\nTexture2D diffuseTexture : register(t0);\\nSamplerState textureSampler : register(s0);\\n\\ncbuffer LightBuffer : register(b0)\\n{\\n    float3 lightDirection;\\n    float lightIntensity;\\n    float4 lightColor;\\n};\\n\\nstruct PixelInput\\n{\\n    float4 position : SV_POSITION;\\n    float3 worldPos : POSITION;\\n    float3 normal : NORMAL;\\n    float2 texCoord : TEXCOORD0;\\n};\\n\\nfloat4 main(PixelInput input) : SV_TARGET\\n{\\n    // 采样漫反射纹理\\n    float4 textureColor = diffuseTexture.Sample(textureSampler, input.texCoord);\\n    \\n    // 计算光照\\n    float3 normalizedNormal = normalize(input.normal);\\n    float lightFactor = max(dot(normalizedNormal, -lightDirection), 0.0f);\\n    \\n    // 计算最终颜色\\n    float4 finalColor = textureColor * lightColor * lightFactor * lightIntensity;\\n    finalColor.a = textureColor.a;\\n    \\n    return finalColor;\\n}\"},{\"type\":\"heading\",\"level\":3,\"id\":\"optimization\",\"text\":\"性能优化技巧\"},{\"type\":\"paragraph\",\"text\":\"优化DirectX 11渲染性能的关键技巧：\"},{\"type\":\"list\",\"items\":[\"**批处理** - 减少Draw Call数量\",\"**实例化渲染** - 高效渲染大量相似对象\",\"**纹理图集** - 减少纹理切换开销\",\"**LOD系统** - 根据距离调整细节级别\",\"**视锥剔除** - 避免渲染不可见对象\"]},{\"type\":\"heading\",\"level\":3,\"id\":\"summary\",\"text\":\"总结\"},{\"type\":\"paragraph\",\"text\":\"DirectX 11渲染管线为现代游戏开发提供了强大而灵活的图形渲染能力。深入理解每个阶段的工作原理和优化方法，是开发高性能游戏引擎的基础。通过合理的设计和优化，可以充分发挥现代GPU的计算能力。\"}],\"navigation\":{\"prev\":{\"title\":\"PhysX物理引擎集成实战\",\"slug\":\"physx-integration-guide\"},\"next\":{\"title\":\"HLSL着色器编程技巧\",\"slug\":\"hlsl-shader-programming\"}}},\"$10\",{\"id\":\"physx-integration-guide\",\"title\":\"PhysX物理引擎集成实战\",\"subtitle\":\"PhysX Integration Guide\",\"category\":\"PhysX\",\"author\":\"HGL\",\"date\":\"2024-01-10\",\"readTime\":\"12分钟\",\"excerpt\":\"从零开始集成PhysX物理引擎到游戏项目中，包括刚体物理、碰撞检测、约束系统等核心功能的实现和优化技巧...\",\"tags\":[\"PhysX\",\"物理引擎\",\"碰撞检测\"],\"featured\":false,\"published\":true,\"content\":[{\"type\":\"heading\",\"level\":2,\"id\":\"intro\",\"text\":\"PhysX物理引擎简介\"},{\"type\":\"paragraph\",\"text\":\"PhysX是NVIDIA开发的实时物理引擎，广泛应用于游戏开发中。它提供了刚体动力学、软体模拟、流体模拟、布料模拟等丰富的物理效果。本文将详细介绍如何在自研游戏引擎中集成PhysX。\"},{\"type\":\"heading\",\"level\":3,\"id\":\"setup\",\"text\":\"环境配置\"},{\"type\":\"paragraph\",\"text\":\"首先需要下载并配置PhysX SDK：\"},{\"type\":\"list\",\"ordered\":true,\"items\":[\"从NVIDIA官网下载PhysX SDK\",\"解压到项目目录\",\"配置Visual Studio项目设置\"]},{\"type\":\"code\",\"language\":\"cpp\",\"code\":\"// 项目配置示例\\n// 包含目录\\n$(PhysXSDK)/Include\\n$(PhysXSDK)/Include/common\\n$(PhysXSDK)/Include/geometry\\n$(PhysXSDK)/Include/foundation\\n\\n// 库目录\\n$(PhysXSDK)/Lib/$(Platform)/$(Configuration)\\n\\n// 链接库\\nPhysX_64.lib\\nPhysXCommon_64.lib\\nPhysXFoundation_64.lib\\nPhysXCooking_64.lib\"},{\"type\":\"heading\",\"level\":3,\"id\":\"init\",\"text\":\"初始化PhysX\"},{\"type\":\"paragraph\",\"text\":\"PhysX的初始化包括创建基金会、物理系统、场景等核心组件：\"},{\"type\":\"code\",\"language\":\"cpp\",\"code\":\"// PhysX初始化代码\\n#include \u003cPxPhysicsAPI.h\u003e\\n\\nusing namespace physx;\\n\\nclass PhysicsManager {\\nprivate:\\n    PxFoundation* foundation;\\n    PxPhysics* physics;\\n    PxScene* scene;\\n    PxDefaultAllocator allocator;\\n    PxDefaultErrorCallback errorCallback;\\n    \\npublic:\\n    bool Initialize() {\\n        // 创建基金会\\n        foundation = PxCreateFoundation(PX_PHYSICS_VERSION, allocator, errorCallback);\\n        if (!foundation) return false;\\n        \\n        // 创建物理系统\\n        physics = PxCreatePhysics(PX_PHYSICS_VERSION, *foundation, PxTolerancesScale());\\n        if (!physics) return false;\\n        \\n        // 创建场景描述\\n        PxSceneDesc sceneDesc(physics-\u003egetTolerancesScale());\\n        sceneDesc.gravity = PxVec3(0.0f, -9.81f, 0.0f);\\n        sceneDesc.cpuDispatcher = PxDefaultCpuDispatcherCreate(2);\\n        sceneDesc.filterShader = PxDefaultSimulationFilterShader;\\n        \\n        // 创建场景\\n        scene = physics-\u003ecreateScene(sceneDesc);\\n        if (!scene) return false;\\n        \\n        return true;\\n    }\\n};\"},{\"type\":\"heading\",\"level\":3,\"id\":\"rigidbody\",\"text\":\"刚体物理\"},{\"type\":\"paragraph\",\"text\":\"刚体是物理引擎中最基本的概念，它具有质量、速度、加速度等物理属性：\"},{\"type\":\"code\",\"language\":\"cpp\",\"code\":\"// 创建刚体\\nPxRigidDynamic* CreateDynamicBox(const PxVec3\u0026 position, const PxVec3\u0026 halfSize, float density) {\\n    // 创建形状\\n    PxShape* shape = physics-\u003ecreateShape(PxBoxGeometry(halfSize), *material);\\n    \\n    // 创建刚体\\n    PxTransform transform(position);\\n    PxRigidDynamic* body = physics-\u003ecreateRigidDynamic(transform);\\n    body-\u003eattachShape(*shape);\\n    \\n    // 计算质量和惯性\\n    PxRigidBodyExt::updateMassAndInertia(*body, density);\\n    \\n    // 添加到场景\\n    scene-\u003eaddActor(*body);\\n    \\n    return body;\\n}\\n\\n// 创建静态物体\\nPxRigidStatic* CreateStaticBox(const PxVec3\u0026 position, const PxVec3\u0026 halfSize) {\\n    // 创建形状\\n    PxShape* shape = physics-\u003ecreateShape(PxBoxGeometry(halfSize), *material);\\n    \\n    // 创建静态物体\\n    PxTransform transform(position);\\n    PxRigidStatic* body = physics-\u003ecreateRigidStatic(transform);\\n    body-\u003eattachShape(*shape);\\n    \\n    // 添加到场景\\n    scene-\u003eaddActor(*body);\\n    \\n    return body;\\n}\"},{\"type\":\"heading\",\"level\":3,\"id\":\"collision\",\"text\":\"碰撞检测\"},{\"type\":\"paragraph\",\"text\":\"PhysX提供了强大的碰撞检测系统，包括碰撞形状、过滤器和碰撞回调：\"},{\"type\":\"code\",\"language\":\"cpp\",\"code\":\"// 碰撞回调类\\nclass CollisionCallback : public PxSimulationEventCallback {\\npublic:\\n    void onContact(const PxContactPairHeader\u0026 pairHeader, \\n                   const PxContactPair* pairs, PxU32 nbPairs) override {\\n        for (PxU32 i = 0; i \u003c nbPairs; i++) {\\n            const PxContactPair\u0026 cp = pairs[i];\\n            \\n            // 检查碰撞开始\\n            if (cp.events \u0026 PxPairFlag::eNOTIFY_TOUCH_FOUND) {\\n                std::cout \u003c\u003c \\\"Collision detected!\\\" \u003c\u003c std::endl;\\n            }\\n            \\n            // 检查碰撞结束\\n            if (cp.events \u0026 PxPairFlag::eNOTIFY_TOUCH_LOST) {\\n                std::cout \u003c\u003c \\\"Collision ended!\\\" \u003c\u003c std::endl;\\n            }\\n        }\\n    }\\n    \\n    // 其他回调函数...\\n};\\n\\n// 设置碰撞过滤\\nvoid SetupCollisionFiltering() {\\n    PxFilterData filterData;\\n    filterData.word0 = 0x1; // 类别1\\n    filterData.word1 = 0x2; // 与类别2碰撞\\n    \\n    PxShape* shape = ...;\\n    shape-\u003esetSimulationFilterData(filterData);\\n}\"},{\"type\":\"heading\",\"level\":3,\"id\":\"optimization\",\"text\":\"性能优化\"},{\"type\":\"paragraph\",\"text\":\"PhysX物理引擎的性能优化是游戏开发中的重要环节：\"},{\"type\":\"list\",\"items\":[\"**批处理** - 减少物理模拟的调用次数\",\"**LOD系统** - 根据距离调整物理精度\",\"**睡眠机制** - 静止物体进入睡眠状态\",\"**区域划分** - 使用空间分区优化碰撞检测\",\"**多线程** - 利用多核CPU进行并行计算\"]},{\"type\":\"code\",\"language\":\"cpp\",\"code\":\"// 性能优化设置\\nvoid OptimizePhysicsScene() {\\n    // 设置时间步长\\n    scene-\u003esetGravity(PxVec3(0.0f, -9.81f, 0.0f));\\n    \\n    // 启用睡眠机制\\n    scene-\u003esetFlag(PxSceneFlag::eENABLE_CCD, true);\\n    scene-\u003esetFlag(PxSceneFlag::eENABLE_ACTIVE_ACTORS, true);\\n    \\n    // 设置求解器迭代次数\\n    scene-\u003esetSolverBatchSize(PxU32(50));\\n    scene-\u003esetSolverIterationCount(4);\\n    \\n    // 启用连续碰撞检测\\n    PxSetWarnOnDeprecatedAPI(true);\\n}\\n\\n// 批处理物理更新\\nvoid UpdatePhysics(float deltaTime) {\\n    // 固定时间步长\\n    const float fixedTimeStep = 1.0f / 60.0f;\\n    accumulator += deltaTime;\\n    \\n    while (accumulator \u003e= fixedTimeStep) {\\n        scene-\u003esimulate(fixedTimeStep);\\n        scene-\u003efetchResults(true);\\n        accumulator -= fixedTimeStep;\\n    }\\n}\"},{\"type\":\"heading\",\"level\":3,\"id\":\"summary\",\"text\":\"总结\"},{\"type\":\"paragraph\",\"text\":\"PhysX物理引擎为游戏开发提供了强大而完整的物理模拟解决方案。通过合理的架构设计和性能优化，可以在游戏中实现逼真的物理效果。掌握PhysX的集成技术，是开发高质量3D游戏的重要技能。\"}],\"navigation\":{\"prev\":{\"title\":\"HLSL着色器编程技巧\",\"slug\":\"hlsl-shader-programming\"},\"next\":{\"title\":\"DirectX 11渲染管线深度解析\",\"slug\":\"directx11-rendering-pipeline\"}}}]}]]}]}],[\"$\",\"div\",null,{\"className\":\"hidden lg:block w-80\",\"children\":[\"$\",\"div\",null,{\"className\":\"sticky top-24 space-y-6\",\"children\":[[\"$\",\"$L2c\",null,{\"post\":\"$10\"}],[\"$\",\"$L2d\",null,{\"post\":\"$10\",\"allPosts\":\"$2e\"}]]}]}]]}]}]}],[\"$\",\"$Le\",null,{\"variant\":\"professional\",\"padding\":\"lg\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-4xl mx-auto\",\"children\":[\"$\",\"$L67\",null,{\"post\":\"$10\"}]}]}]]}],[\"$\",\"$L68\",null,{}]]}],null],\"segment\":\"__PAGE__?{\\\"slug\\\":\\\"hlsl-shader-programming\\\"}\"},\"styles\":null}],\"segment\":[\"slug\",\"hlsl-shader-programming\",\"d\"]},\"styles\":null}],\"segment\":\"blog\"},\"styles\":null}]}]]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"4:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"HLSL着色器编程技巧 - HGL技术博客\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"分享HLSL着色器开发中的实用技巧，包括顶点着色器、像素着色器的优化方法，以及常用的视觉效果实现...\"}],[\"$\",\"meta\",\"4\",{\"name\":\"author\",\"content\":\"HGL\"}],[\"$\",\"meta\",\"5\",{\"name\":\"keywords\",\"content\":\"HLSL, 着色器, 渲染\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:title\",\"content\":\"HLSL着色器编程技巧\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:description\",\"content\":\"分享HLSL着色器开发中的实用技巧，包括顶点着色器、像素着色器的优化方法，以及常用的视觉效果实现...\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"9\",{\"property\":\"article:published_time\",\"content\":\"2024-01-05\"}],[\"$\",\"meta\",\"10\",{\"property\":\"article:author\",\"content\":\"HGL\"}],[\"$\",\"meta\",\"11\",{\"property\":\"article:tag\",\"content\":\"HLSL\"}],[\"$\",\"meta\",\"12\",{\"property\":\"article:tag\",\"content\":\"着色器\"}],[\"$\",\"meta\",\"13\",{\"property\":\"article:tag\",\"content\":\"渲染\"}],[\"$\",\"meta\",\"14\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"15\",{\"name\":\"twitter:title\",\"content\":\"HLSL着色器编程技巧\"}],[\"$\",\"meta\",\"16\",{\"name\":\"twitter:description\",\"content\":\"分享HLSL着色器开发中的实用技巧，包括顶点着色器、像素着色器的优化方法，以及常用的视觉效果实现...\"}],[\"$\",\"link\",\"17\",{\"rel\":\"icon\",\"href\":\"/icon.ico?566750784894397f\",\"type\":\"image/x-icon\",\"sizes\":\"64x64\"}]]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>